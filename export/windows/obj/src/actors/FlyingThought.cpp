// Generated by Haxe 4.1.2
#include <hxcpp.h>

#ifndef INCLUDED_actors_FlyingThought
#include <actors/FlyingThought.h>
#endif
#ifndef INCLUDED_actors_FlyingThoughtType
#include <actors/FlyingThoughtType.h>
#endif
#ifndef INCLUDED_actors_FlyingThoughts
#include <actors/FlyingThoughts.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRandom
#include <flixel/math/FlxRandom.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_8486c0f1af35c070_67_new,"actors.FlyingThought","new",0x4251568c,"actors.FlyingThought.new","actors/FlyingThoughts.hx",67,0x822070a4)
HX_LOCAL_STACK_FRAME(_hx_pos_8486c0f1af35c070_82_update,"actors.FlyingThought","update",0x90d5235d,"actors.FlyingThought.update","actors/FlyingThoughts.hx",82,0x822070a4)
namespace actors{

void FlyingThought_obj::__construct(Float x, ::actors::FlyingThoughtType type){
            	HX_STACKFRAME(&_hx_pos_8486c0f1af35c070_67_new)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(type,"type")
HXLINE(  67)
HXLINE(  68)		super::__construct(x,::actors::FlyingThoughts_obj::rand->_hx_float(0,99,null()),null());
HXLINE(  69)		 ::Dynamic _hx_tmp;
HXDLIN(  69)		if (::hx::IsEq( type,::actors::FlyingThoughtType_obj::GOOD_dyn() )) {
HXLINE(  69)			_hx_tmp = HX_("assets/images/goodthought.png",2c,7c,06,e4);
            		}
            		else {
HXLINE(  69)			_hx_tmp = HX_("assets/images/badthought.png",da,48,ba,d4);
            		}
HXDLIN(  69)		this->loadGraphic(_hx_tmp,true,8,8,null(),null());
HXLINE(  71)		this->type = type;
HXLINE(  73)		if ((x > ::flixel::FlxG_obj::width)) {
HXLINE(  74)			Float _hx_tmp;
HXDLIN(  74)			if (::hx::IsEq( type,::actors::FlyingThoughtType_obj::GOOD_dyn() )) {
HXLINE(  74)				_hx_tmp = ::actors::FlyingThoughts_obj::rand->_hx_float(-45,-75,null());
            			}
            			else {
HXLINE(  74)				_hx_tmp = ::actors::FlyingThoughts_obj::rand->_hx_float(-60,-75,null());
            			}
HXDLIN(  74)			this->SPEED = _hx_tmp;
HXLINE(  75)			this->destroyDistance = ( (Float)(-5) );
            		}
            		else {
HXLINE(  76)			if ((x < 0)) {
HXLINE(  77)				Float _hx_tmp;
HXDLIN(  77)				if (::hx::IsEq( type,::actors::FlyingThoughtType_obj::GOOD_dyn() )) {
HXLINE(  77)					_hx_tmp = ::actors::FlyingThoughts_obj::rand->_hx_float(45,75,null());
            				}
            				else {
HXLINE(  77)					_hx_tmp = ::actors::FlyingThoughts_obj::rand->_hx_float(60,75,null());
            				}
HXDLIN(  77)				this->SPEED = _hx_tmp;
HXLINE(  78)				this->destroyDistance = ( (Float)((::flixel::FlxG_obj::width + 5)) );
            			}
            		}
            	}

Dynamic FlyingThought_obj::__CreateEmpty() { return new FlyingThought_obj; }

void *FlyingThought_obj::_hx_vtable = 0;

Dynamic FlyingThought_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FlyingThought_obj > _hx_result = new FlyingThought_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool FlyingThought_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2c01639b) {
		if (inClassId<=(int)0x19c891c4) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x19c891c4;
		} else {
			return inClassId==(int)0x2c01639b;
		}
	} else {
		return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
	}
}

void FlyingThought_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_8486c0f1af35c070_82_update)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(elapsed,"elapsed")
HXLINE(  82)
HXLINE(  83)		this->velocity->set_x(this->SPEED);
HXLINE(  85)		if ((this->x == this->destroyDistance)) {
HXLINE(  86)			this->kill();
HXLINE(  87)			this->destroy();
            		}
HXLINE(  90)		this->super::update(elapsed);
            	}



::hx::ObjectPtr< FlyingThought_obj > FlyingThought_obj::__new(Float x, ::actors::FlyingThoughtType type) {
	::hx::ObjectPtr< FlyingThought_obj > __this = new FlyingThought_obj();
	__this->__construct(x,type);
	return __this;
}

::hx::ObjectPtr< FlyingThought_obj > FlyingThought_obj::__alloc(::hx::Ctx *_hx_ctx,Float x, ::actors::FlyingThoughtType type) {
	FlyingThought_obj *__this = (FlyingThought_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(FlyingThought_obj), true, "actors.FlyingThought"));
	*(void **)__this = FlyingThought_obj::_hx_vtable;
	__this->__construct(x,type);
	return __this;
}

FlyingThought_obj::FlyingThought_obj()
{
}

void FlyingThought_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlyingThought);
	HX_MARK_MEMBER_NAME(type,"type");
	HX_MARK_MEMBER_NAME(SPEED,"SPEED");
	HX_MARK_MEMBER_NAME(destroyDistance,"destroyDistance");
	 ::flixel::FlxSprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void FlyingThought_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(type,"type");
	HX_VISIT_MEMBER_NAME(SPEED,"SPEED");
	HX_VISIT_MEMBER_NAME(destroyDistance,"destroyDistance");
	 ::flixel::FlxSprite_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val FlyingThought_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { return ::hx::Val( type ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"SPEED") ) { return ::hx::Val( SPEED ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"destroyDistance") ) { return ::hx::Val( destroyDistance ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val FlyingThought_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { type=inValue.Cast<  ::actors::FlyingThoughtType >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"SPEED") ) { SPEED=inValue.Cast< Float >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"destroyDistance") ) { destroyDistance=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void FlyingThought_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("type",ba,f2,08,4d));
	outFields->push(HX_("SPEED",67,cf,57,ff));
	outFields->push(HX_("destroyDistance",4f,06,fe,dd));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo FlyingThought_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::actors::FlyingThoughtType */ ,(int)offsetof(FlyingThought_obj,type),HX_("type",ba,f2,08,4d)},
	{::hx::fsFloat,(int)offsetof(FlyingThought_obj,SPEED),HX_("SPEED",67,cf,57,ff)},
	{::hx::fsFloat,(int)offsetof(FlyingThought_obj,destroyDistance),HX_("destroyDistance",4f,06,fe,dd)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *FlyingThought_obj_sStaticStorageInfo = 0;
#endif

static ::String FlyingThought_obj_sMemberFields[] = {
	HX_("type",ba,f2,08,4d),
	HX_("SPEED",67,cf,57,ff),
	HX_("destroyDistance",4f,06,fe,dd),
	HX_("update",09,86,05,87),
	::String(null()) };

::hx::Class FlyingThought_obj::__mClass;

void FlyingThought_obj::__register()
{
	FlyingThought_obj _hx_dummy;
	FlyingThought_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("actors.FlyingThought",9a,60,30,28);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(FlyingThought_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< FlyingThought_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlyingThought_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlyingThought_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace actors
